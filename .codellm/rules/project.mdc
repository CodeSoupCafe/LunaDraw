---
description: 
globs: 
alwaysApply: true
---

### 1. Single Responsibility Principle (SRP)
```csharp
// Adherence: Separate services for each responsibility.
public class AuthenticationService {
    public bool AuthenticateUser(string u, string p) { /* ... */ }
}
public class UserRepository {
    public User GetUserById(int id) { /* ... */ }
}
public class EmailService {
    public void SendWelcomeEmail(User u) { /* ... */ }
}
````


### 2\. Open/Closed Principle (OCP)


```java
// Adherence: Use an abstraction (interface) to allow extension.
interface TaxStrategy { double calculateTax(double amount); }
class SalesTaxStrategy implements TaxStrategy { /* ... */ }
class VATTaxStrategy implements TaxStrategy { /* ... */ }


class TaxCalculator {
    private TaxStrategy _strategy;
    public TaxCalculator(TaxStrategy strategy) { _strategy = strategy; }
    public double calculateTotalTax(double amount) {
        return _strategy.calculateTax(amount);
    }
}
```


### 3\. Liskov Substitution Principle (LSP)


```python
# Violation: Square breaks Rectangle's behavior.
class Rectangle:
    def set_width(self, w): self.width = w
    def set_height(self, h): self.height = h


class Square(Rectangle):
    def set_width(self, side):
        self.width = side
        self.height = side # Breaks LSP
```


### 4\. Interface Segregation Principle (ISP)


```csharp
// Adherence: Smaller, specific interfaces.
public interface ICarService {
    void StartCar(); void StopCar();
}
public interface ITruckService {
    void StartTruck(); void StopTruck();
}
public class CarService : ICarService {
    public void StartCar() { /* ... */ }
    public void StopCar() { /* ... */ }
}
```


### 5\. Dependency Inversion Principle (DIP)


```java
// Adherence: Depend on abstractions (interfaces), not concretions.
public interface IPaymentGateway { void makePayment(double amount); }
public class PayPalGateway implements IPaymentGateway { /* ... */ }


public class OrderProcessor {
    private IPaymentGateway _gateway;
    public OrderProcessor(IPaymentGateway gateway) { _gateway = gateway; }
    public void processOrder(Order order) {
        _gateway.makePayment(order.getAmount());
    }
}
```


-----


### 6\. DRY (Don't Repeat Yourself)


```xml
<Application.Resources>
    <Style x:Key="PrimaryButton" TargetType="Button">
        <Setter Property="BackgroundColor" Value="Blue" />
        <Setter Property="CornerRadius" Value="8" />
    </Style>
</Application.Resources>


<Button Text="Submit" Style="{StaticResource PrimaryButton}" />
<Button Text="Login" Style="{StaticResource PrimaryButton}" />
```


```csharp
// Adherence (C#): Use an extension method for repeated logic.
public static class ReactiveExtensions
{
    public static IDisposable HandleErrors(this IObservable<Exception> stream)
    {
        return stream.Subscribe(ex => Shell.Current.DisplayAlert("Error", ...));
    }
}
// Usage
SaveCommand.ThrownExceptions.HandleErrors();
LoadCommand.ThrownExceptions.HandleErrors();
```


-----


### 7\. Low Coupling


```csharp       
// Adherence: Use a Message Bus. ViewModels don't know about each other.
public class UserLoggedInMessage { }


public class LoginViewModel : ReactiveObject
{
    public LoginViewModel() {
        LoginCommand = ReactiveCommand.Create(() => {
            MessageBus.Current.SendMessage(new UserLoggedInMessage());
        });
    }       
}
public class MainViewModel : ReactiveObject
{
    public MainViewModel() {
        MessageBus.Current.Listen<UserLoggedInMessage>()
            .InvokeCommand(LoadDataCommand);
    }
}       
```


-----


### 8\. High Cohesion


```csharp
// Adherence: Each class has one focused job.
public class LoginViewModel : ReactiveObject
{
    [Reactive] public string UserName { get; set; }
    public ReactiveCommand<Unit, Unit> LoginCommand { get; }
}
public class SettingsViewModel : ReactiveObject
{
    [Reactive] public bool IsDarkMode { get; set; }
    public ReactiveCommand<Unit, Unit> SaveSettingsCommand { get; }
}
public class ProfileViewModel : ReactiveObject
{
    [Reactive] public string ProfileImageUrl { get; set; }
    public ReactiveCommand<Unit, Unit> UploadImageCommand { get; }
}
```


-----


### 9\. Separation of Concerns (SoC) & Modularity


```csharp
// Adherence: MVVM pattern separates View, ViewModel, and Services.


// Concern 1: View (XAML) - Layout
<Entry Text="{Binding UserName}" />
<Button Command="{Binding LoginCommand}" />


// Concern 2: ViewModel (C#) - UI State & Intent
public class LoginViewModel : ReactiveObject
{
    private readonly IAuthService _auth;
    [Reactive] public string UserName { get; set; }
    public ReactiveCommand<Unit, bool> LoginCommand { get; }


    public LoginViewModel(IAuthService auth) {
        _auth = auth;
        LoginCommand = ReactiveCommand.CreateFromTask(() => _auth.LoginAsync(UserName));
    }
}


// Concern 3: Service (C#) - Business Logic / Data
public class AuthService : IAuthService
{
    public async Task<bool> LoginAsync(string user) { /* ... */ }
}
```